var documenterSearchIndex = {"docs":
[{"location":"getting-started/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"getting-started/installation/#1.-Create-a-Dedicated-Julia-Environment-(Highly-Recommended)","page":"Installation","title":"1. Create a Dedicated Julia Environment (Highly Recommended)","text":"We strongly recommend creating a dedicated Julia environment for MyJuliVQC.jl to prevent dependency conflicts with other projects. Follow these steps:\n\nOpen the Julia REPL.  \nNavigate to your project folder (or any desired directory).  \nActivate a new environment:  \njulia> ] activate .\njulia> ] instantiate\nThis creates a new Project.toml and an empty environment in the current folder.\n\n","category":"section"},{"location":"getting-started/installation/#2.-Install-MyJuliVQC","page":"Installation","title":"2. Install MyJuliVQC","text":"MyJuliVQC can be installed directly from GitHub:    julia    julia> ] add https://github.com/HanDirac/MyJuliVQC.jl\n\nThen load the package:        julia    julia> using MyJuliVQC\n\nIf this succeeds without errors, the installation is complete.\n\n","category":"section"},{"location":"manual/noise-channels/#Noise-Channels","page":"Noise channels","title":"Noise Channels","text":"In addition to unitary quantum gates, realistic quantum circuits must also account for noise.\n\nNoise processes are mathematically described by quantum channels, which generalize unitary evolution and allow non-unitary dynamics such as decoherence and relaxation.\n\nIn MyJuliVQC, quantum channels are represented using the Kraus operator formalism, providing a flexible and unified way to model general noisy processes.\n\n","category":"section"},{"location":"manual/noise-channels/#Defining-General-Quantum-Channels","page":"Noise channels","title":"Defining General Quantum Channels","text":"MyJuliVQC offers a universal constructor:\n\nQuantumMap(positions, kraus)\n\nwhere:\n\npositions specifies the qubits on which the channel acts (e.g., (1,), (2, 3));\nkraus is a vector of matrices\n\n<div align=\"center\"> { K<sub>ℓ</sub> } </div>\n\nrepresenting the channel through\n\n<div align=\"center\"> ρ ↦ ∑<sub>ℓ</sub> K<sub>ℓ</sub> ρ K<sub>ℓ</sub><sup>†</sup>. </div>\n\nThis interface allows the user to define arbitrary custom noise models, from single-qubit decoherence to multi-qubit correlated channels.\n\nExample (defining a custom single-qubit channel):\n\nusing MyJuliVQC\n\nK1 = [1 0; 0 sqrt(0.8)]\nK2 = [0 sqrt(0.2); 0 0]\n\nmy_channel = QuantumMap(1, [K1, K2])   \n\n","category":"section"},{"location":"manual/noise-channels/#Built-in-Noise-Channels","page":"Noise channels","title":"Built-in Noise Channels","text":"For convenience, MyJuliVQC provides several commonly used single-qubit quantum channels as simple wrappers of QuantumMap. These include:\n\nAmplitudeDamping(pos, p)\nPhaseDamping(pos, p)\nDepolarizing(pos, p)\n\nEach constructor automatically generates the corresponding Kraus operators and returns a QuantumMap. (Internally, these functions do not use any hardware-specific optimizations; they are implemented in a clean and transparent way suitable for research and educational use.)\n\nExample:\n\nusing MyJuliVQC\n\nchannel = AmplitudeDamping(1, 0.1)","category":"section"},{"location":"examples/flux-example/#Flux-Example","page":"A Simple Application with Flux","title":"Flux Example","text":"","category":"section"},{"location":"examples/utilities/#Utilities","page":"Utility Functions","title":"Utilities","text":"","category":"section"},{"location":"manual/initialize-state/#Initialize-State","page":"Initialize a quantum state","title":"Initialize State","text":"The first step in using MyJuliVQC for quantum circuit simulation is to initialize a quantum state represented as a state vector. MyJuliVQC provides two constructors: StateVector for pure states and DensityMatrix for mixed states. \n\nFrom a mathematical viewpoint:\n\nAn n-qubit pure state should be understood as a a vector of size 2^n, corresponding to a rank-n tensor with each index of dimension 2.\nAn n-qubit mixed state is represented as a density matrix of size 2^n2^n, which can be viewed as a rank-2n tensor where each dimension also has size 2.\n\nInternal index conventions:\n\nFor pure states, qubits are internally labeled from 1 to n.\nFor mixed states, the ket indices are labeled from 1 to n, and the corresponding bra indices from n+1 to 2n.\n\nBoth state representations use column-major storage, meaning lower-index dimensions vary fastest.\n\nThese implementation details are generally irrelevant to typical users unless direct access to the raw data is required.\n\nusing MyJuliVQC\n\n# Initialize |00⟩ for 2 qubits\nstate = StateVector(2)\n\nn = 2\npure_state  = StateVector(n)\nmixed_state = DensityMatrix(n)\n\n# Custom pure state (user-specified vector)\ncustom_pure_state = StateVector([0.0, 0.1, 0.0, 0.0])\n\n# Custom mixed state (user-specified flattened matrix)\n# NOTE:\n#   If a vector is used to construct a DensityMatrix,\n#   **the vector must follow column-major (column-first) order**.\n#   That is, the matrix is flattened by stacking all columns in sequence.\ncustom_mixed_state = DensityMatrix([0.5, -0.5im, 0.5im, 0.5]) #column-major order)\n\n# -------------------------------------------------------\n# Construct an equivalent mixed state using a 2×2 matrix\n# -------------------------------------------------------\n\n# 2×2 density matrix explicitly written\nρmat = [\n    0.5      0.5im;\n   -0.5im    0.5\n]\n\n# Construct DensityMatrix from matrix form\nmixed_state_from_matrix = DensityMatrix(ρmat)\n\n# -------------------------------------------------------\n# Test equivalence\n# -------------------------------------------------------\n\nprintln(\"custom_mixed_state data = \", custom_mixed_state.data)\nprintln(\"mixed_state_from_matrix data = \", mixed_state_from_matrix.data)\n\n# They should match element-wise\nprintln(\"Are the two density matrices equal? \",\n        custom_mixed_state.data ≈ mixed_state_from_matrix.data)\n","category":"section"},{"location":"manual/threading-control/#Threading-Control-(MyJuliVQC-Extension)","page":"Threading control (MyJuliVQC)","title":"Threading Control (MyJuliVQC Extension)","text":"MyJuliVQC provides an optional threading-control interface that gives users more flexibility than the original JuliVQC implementation. It allows fine-grained control over how parallelism is applied during quantum-state evolution, which is important for large circuits or multi-core/HPC environments.\n\nThe configuration is done through:\n\nMyJuliVQC.set_threading!(;\n    outer_threads = true,\n    dloc_threshold = 8,\n    blas_threads = nothing,\n)\n\nThis document explains:\n\nwhat each threading parameter means,\nhow MyJuliVQC applies threading internally,\ninteraction with BLAS-level threading,\nrecommended settings for laptops, workstations, and HPC clusters.\n\n","category":"section"},{"location":"manual/threading-control/#Global-Threading-Strategy","page":"Threading control (MyJuliVQC)","title":"Global Threading Strategy","text":"MyJuliVQC uses two potential sources of parallelism:\n\nOuter-level threading   When applying small gates (1–2 qubits) to a large state vector, MyJuliVQC may distribute the work across Julia threads. This is also used for some density-matrix kernels.\nBLAS-level threading   Some operations, especially involving large density matrices, rely on BLAS routines (MKL, OpenBLAS, etc.), which may themselves use multi-threading internally.\n\nUsing both at once may cause oversubscription. The function set_threading! helps control this balance.\n\n","category":"section"},{"location":"manual/threading-control/#Configuration-Interface","page":"Threading control (MyJuliVQC)","title":"Configuration Interface","text":"","category":"section"},{"location":"manual/threading-control/#Parameter:-outer_threads","page":"Threading control (MyJuliVQC)","title":"Parameter: outer_threads","text":"Controls whether MyJuliVQC uses Julia-level Threads.@threads for gate-application loops.\n\nouter_threads = true    # enable outer-level parallel loops\nouter_threads = false   # disable outer-level parallelism\n\nSituations where setting this to false is beneficial:\n\nwhen BLAS is using many threads,\nwhen oversubscription occurs,\nwhen benchmarking indicates BLAS dominates performance.\n\n","category":"section"},{"location":"manual/threading-control/#Parameter:-dloc_threshold","page":"Threading control (MyJuliVQC)","title":"Parameter: dloc_threshold","text":"Controls when outer threading is allowed.\n\ndloc = local dimension of a gate = 2^k for a k-qubit gate.\nIf dloc <= dloc_threshold, MyJuliVQC may activate outer threading.\n\nExample meanings:\n\ndloc_threshold = 8    # allow threading for gates up to 3 qubits\ndloc_threshold = 4    # allow threading only for 1–2 qubit gates\n\n","category":"section"},{"location":"manual/threading-control/#Parameter:-blas_threads","page":"Threading control (MyJuliVQC)","title":"Parameter: blas_threads","text":"Optional argument to configure BLAS:\n\nblas_threads = N       # attempt to set BLAS to use N threads\nblas_threads = nothing # leave BLAS thread count unchanged (default)\n\nSome BLAS installations may not support runtime thread changes; MyJuliVQC silently ignores errors in such cases.\n\nSetting blas_threads = 1 is often useful if relying mostly on Julia threads.\n\n","category":"section"},{"location":"manual/threading-control/#Example-Usage","page":"Threading control (MyJuliVQC)","title":"Example Usage","text":"using MyJuliVQC\n\nMyJuliVQC.set_threading!(;\n    outer_threads = true,\n    dloc_threshold = 8,\n    blas_threads = 1,\n)\n\nThis configuration:\n\nenables outer-level threading,\napplies it to small gates,\nrestricts BLAS to a single thread.\n\n","category":"section"},{"location":"manual/threading-control/#Internal-Usage","page":"Threading control (MyJuliVQC)","title":"Internal Usage","text":"MyJuliVQC stores configuration using:\n\n_USE_OUTER_THREADS[]        # reflective boolean flag\n_DLOC_THREAD_THRESHOLD[]    # integer threshold for small gates\n\nand provides internal helper functions:\n\nuse_outer_threads()\ndloc_thread_threshold()\n\nThese are not exported, but used by the kernel implementation.\n\n","category":"section"},{"location":"manual/threading-control/#Recommended-Configurations","page":"Threading control (MyJuliVQC)","title":"Recommended Configurations","text":"","category":"section"},{"location":"manual/threading-control/#Laptops-(4–8-cores)","page":"Threading control (MyJuliVQC)","title":"Laptops (4–8 cores)","text":"set_threading!(;\n    outer_threads = true,\n    dloc_threshold = 8,\n    blas_threads = 1,\n)","category":"section"},{"location":"manual/threading-control/#Workstations-(16–32-cores)","page":"Threading control (MyJuliVQC)","title":"Workstations (16–32 cores)","text":"set_threading!(;\n    outer_threads = true,\n    dloc_threshold = 12,\n    blas_threads = 4,\n)","category":"section"},{"location":"manual/threading-control/#HPC-Nodes-(32–128-cores)","page":"Threading control (MyJuliVQC)","title":"HPC Nodes (32–128+ cores)","text":"set_threading!(;\n    outer_threads = false,\n    dloc_threshold = 16,\n    blas_threads = 16,\n)\n\nHPC nodes typically benefit from strong BLAS kernels rather than Julia-threaded outer loops.\n\n","category":"section"},{"location":"manual/threading-control/#Notes","page":"Threading control (MyJuliVQC)","title":"Notes","text":"MyJuliVQC does not yet include specialized gate kernels like the original JuliVQC, so threading strategy can significantly affect performance.\nUsers should benchmark real workloads to determine optimal settings.\nFuture versions may include adaptive heuristics for automatically balancing Julia-level and BLAS-level threading.","category":"section"},{"location":"getting-started/quick-start/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"This page provides a short hands-on introduction to MyJuliVQC, showing how to construct, apply, and differentiate variational quantum circuits.\n\n","category":"section"},{"location":"getting-started/quick-start/#Example-1:-Preparing-a-Bell-State","page":"Quick Start","title":"Example 1: Preparing a Bell State","text":"The following script initializes a 2-qubit state, applies a simple quantum circuit, and performs a measurement:\n\nusing MyJuliVQC\n\n# Create a 2-qubit state |00⟩\nψ = StateVector(2)\n\n# Build a quantum circuit\ncircuit = QCircuit()\npush!(circuit, HGate(1))          # Hadamard on qubit 1\npush!(circuit, CNOTGate(1, 2))    # Controlled-NOT from qubit 1 to 2\n\n# Apply the circuit to the state\napply!(circuit, ψ)\n\n# Inspect the resulting state\nprintln(\"Final state vector:\")\nprintln(ψ)\n\n# Measure qubit 1\noutcome, prob = measure!(ψ, 1)\nprintln(\"Measured qubit 1 → $outcome   (probability = $prob)\")\n\n","category":"section"},{"location":"getting-started/quick-start/#Example-2:-A-Simple-Variational-Circuit","page":"Quick Start","title":"Example 2: A Simple Variational Circuit","text":"This example shows how to construct a parameterized circuit and evaluate a loss function:\n\nusing MyJuliVQC\nconst gradientMJVQC = MyJuliVQC.gradient\n\n# 1. initial state\nL  = 3                      # number of qubits\nψ0 = StateVector(L)         # |000⟩\n\n# 2. construct a simple variational circuit\ncircuit = QCircuit()\n\n# Layer 1: single-qubit rotations\nfor i in 1:L\n    push!(circuit, RzGate(i, rand(), isparas=true))\n    push!(circuit, RyGate(i, rand(), isparas=true))\n    push!(circuit, RzGate(i, rand(), isparas=true))\nend\n\n# Layer 2: entangling + rotations\nfor i in 1:L-1\n    push!(circuit, CNOTGate(i, i+1))\nend\nfor i in 1:L\n    push!(circuit, RxGate(i, rand(), isparas=true))\nend\n\n# 3. define a simple operator H\nH = QubitsOperator([QubitsTerm(1=>\"Z\", 2=>\"Z\", 3=>\"Z\"; coeff=1.0)])\n\n# 4. construct the loss\nloss_obj = LossExpectationRealSV(H, ψ0)\n\n# 5. compute the loss(expectation) with the current circuit\nprintln(\"Expectation value (loss) = \", loss_obj(circuit))\n\n# 6. use gradient to get the gradient\ngrads = gradientMJVQC(loss_obj, circuit)\nprintln(\"Gradient from MyJuliVQC.gradient:\")\nprintln(grads)\n\n\n","category":"section"},{"location":"manual/automatic-differentiation/#Automatic-Differentiation","page":"Automatic differentiation","title":"Automatic Differentiation","text":"","category":"section"},{"location":"manual/qubit-operators/#Qubit-Operators","page":"Qubit operators","title":"Qubit Operators","text":"","category":"section"},{"location":"manual/quantum-gates/#Quantum-Gates","page":"Quantum gates","title":"Quantum Gates","text":"The second step of using MyJuliVQC is to build a quantum circuit, which requires specifying the elementary quantum gate operations (and, for noisy circuits, quantum channels).\n\nThe most general way to define a quantum gate in MyJuliVQC is via the constructor\n\nQuantumGate(positions, data)\n\nwhere:\n\npositions specifies the qubit indices that the gate acts on, e.g. (1, 3) for a two-qubit gate on qubits 1 and 3;\ndata is the raw matrix of the gate, which should be a unitary matrix of size 2^k × 2^k for a k-qubit gate.\n\nInternally, MyJuliVQC uses column-major ordering (Julia’s default) for storing gate matrices and state data.\n\n","category":"section"},{"location":"manual/quantum-gates/#Built-in-Quantum-Gates","page":"Quantum gates","title":"Built-in Quantum Gates","text":"For convenience, MyJuliVQC also provides named constructors for commonly used quantum gates:\n\nXGate, YGate, ZGate, SGate, HGate, sqrtXGate, sqrtYGate, TGate, SWAPGate, iSWAPGate, CZGate, CNOTGate, TOFFOLIGate, FREDKINGate, RxGate, RyGate,RzGate, CRxGate, CRyGate, CRzGate, FSIMGate. \n\nIn the current implementation of MyJuliVQC, these special gates are implemented as thin wrappers around the generic QuantumGate constructor. This design keeps the code transparent and easy to read. Future versions may introduce specialized, highly optimized kernels for some of these gates, but the public API will remain the same.\n\n","category":"section"},{"location":"manual/quantum-gates/#Controlled-Gates","page":"Quantum gates","title":"Controlled Gates","text":"MyJuliVQC supports generic controlled operations via dedicated constructors:\n\nCONTROLGate(i, j, data): a controlled single-qubit gate  \ni: control qubit  \nj: target qubit  \ndata: the 2×2 matrix of the target single-qubit operation\nCONTROLCONTROLGate(i, j, k, data): a doubly controlled single-qubit gate  \ni, j: control qubits  \nk: target qubit  \ndata: again the 2×2 matrix acting on the target qubit\n\nThese constructors are convenient when you want to promote an arbitrary single-qubit gate to a (multi-)controlled version without manually building the full 2^n × 2^n matrix.\n\n","category":"section"},{"location":"manual/quantum-gates/#Parametric-Quantum-Gates","page":"Quantum gates","title":"Parametric Quantum Gates","text":"Many variational algorithms require parameterized gates.   In MyJuliVQC, such gates follow a unified interface\n\nG(i..., paras; isparas)\n\nwhere:\n\nG is a gate constructor such as RxGate, RyGate, RzGate, FSIMGate, etc.;\ni... are the qubit indices;\nparas is either:\na single scalar (for one-parameter gates), or\nan array of scalars (for multi-parameter gates);\nisparas is a Boolean keyword:\nisparas = false: the gate is treated as a fixed numerical gate;\nisparas = true: the gate is treated as having optimizable parameters, and its parameters will be tracked by the variational/gradient engine.\n\n","category":"section"},{"location":"manual/quantum-gates/#Examples:-Non-Parametric-and-Parametric-Gates","page":"Quantum gates","title":"Examples: Non-Parametric and Parametric Gates","text":"The following code illustrates how to construct basic non-parametric and parametric gates in MyJuliVQC:\n\nusing MyJuliVQC\n\n# Single-qubit X gate on qubit 1\nn = 1\nX = XGate(n)\n\n# Two-qubit CNOT: control = 1, target = 2\nncontrol = 1\nntarget  = 2\nCNOT = CNOTGate(ncontrol, ntarget)\n\n# Rx gate: non-parametric vs parametric\nθ = π / 2\n\n# a non-parametric Rx gate (angle fixed, not tracked as a variational parameter)\nnon_para_Rx = RxGate(n, θ; isparas = false)\n\n# a parametric Rx gate (its angle is treated as a variational parameter)\npara_Rx = RxGate(n, θ; isparas = true)","category":"section"},{"location":"manual/circuits/#Circuits","page":"Manipulating and running circuits","title":"Circuits","text":"In MyJuliVQC, a quantum circuit is represented by a lightweight wrapper type QCircuit, which internally stores a sequence of quantum operations.\n\nEach element of a QCircuit can be:\n\na (possibly parametric) unitary gate (e.g. HGate, RxGate, CNOTGate, …),\na quantum channel (e.g. AmplitudeDamping, Depolarizing, or a general QuantumMap),\nor another QCircuit (allowing circuit composition via concatenation of subcircuits).\n\nThis design keeps the circuit object simple and transparent while still being flexible enough to represent both noiseless and noisy variational circuits.\n\n","category":"section"},{"location":"manual/circuits/#Applying-a-Circuit-to-a-State","page":"Manipulating and running circuits","title":"Applying a Circuit to a State","text":"After constructing a circuit, you can apply it to a quantum state using:\n\napply!(circuit, state) – in-place evolution (modifies state directly)\napply(circuit, state) – out-of-place evolution (returns a new state)\ncircuit * state – equivalent to apply(circuit, state)\n\nHere, state can be either:\n\nStateVector – representing a pure state, or\nDensityMatrix – representing a mixed state (needed when quantum channels are present).\n\nFor variational quantum algorithms, the out-of-place form is often convenient, since it allows you to treat the circuit as a pure transformation and reuse the initial state.\n\n","category":"section"},{"location":"manual/circuits/#Example:-Building-and-Running-a-Simple-Circuit","page":"Manipulating and running circuits","title":"Example: Building and Running a Simple Circuit","text":"using MyJuliVQC\n\n# Initialize a 2-qubit |00⟩ state\nstate = StateVector(2)\n\n# Construct a circuit:\n#   1. H on qubit 1\n#   2. Ry(π/4) on qubit 1 (non-parametric here)\n#   3. CNOT with control = 1, target = 2\ncircuit = QCircuit([\n    HGate(1),\n    RyGate(1, π/4; isparas = false),\n    CNOTGate(1, 2),\n])\n\n# Apply the circuit in-place\napply!(circuit, state)\n\n# Measure qubit 2\noutcome, prob = measure!(state, 2)\nprintln(\"Measurement result on qubit 2 = $outcome (prob = $prob)\")\n\nYou can also build the same circuit incrementally:\n\nusing MyJuliVQC\n\nstate = StateVector(2)\ncircuit = QCircuit()\n\npush!(circuit, HGate(1))\npush!(circuit, RyGate(1, π/4; isparas = false))\npush!(circuit, CNOTGate(1, 2))\n\nψ_out = apply(circuit, state)   # out-of-place application\n\nIn more advanced workflows, parametric gates (with isparas = true) can be used together with the gradient engine described in the Automatic differentiation section to implement VQE, quantum classifiers, and other variational algorithms.","category":"section"},{"location":"examples/vqc-example/#VQC-example","page":"Creating a Variational Quantum Circuit","title":"VQC-example","text":"","category":"section"},{"location":"#MyJuliVQC.jl-Documentation","page":"Home","title":"MyJuliVQC.jl Documentation","text":"MyJuliVQC.jl is an independent Julia implementation of variational quantum circuit (VQC) simulation methods, inspired by JuliVQC.jl.\n\nStart from the Getting Started section to install and run basic examples.","category":"section"}]
}
