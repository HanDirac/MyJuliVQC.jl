var documenterSearchIndex = {"docs":
[{"location":"getting-started/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"getting-started/installation/#1.-Create-a-Dedicated-Julia-Environment-(Highly-Recommended)","page":"Installation","title":"1. Create a Dedicated Julia Environment (Highly Recommended)","text":"We strongly recommend creating a dedicated Julia environment for MyJuliVQC.jl to prevent dependency conflicts with other projects. Follow these steps:\n\nOpen the Julia REPL.  \nNavigate to your project folder (or any desired directory).  \nActivate a new environment:  \njulia> ] activate .\njulia> ] instantiate\nThis creates a new Project.toml and an empty environment in the current folder.\n\n","category":"section"},{"location":"getting-started/installation/#2.-Install-MyJuliVQC","page":"Installation","title":"2. Install MyJuliVQC","text":"MyJuliVQC can be installed directly from GitHub:    julia    julia> ] add https://github.com/HanDirac/MyJuliVQC.jl\n\nThen load the package:        julia    julia> using MyJuliVQC\n\nIf this succeeds without errors, the installation is complete.\n\n","category":"section"},{"location":"manual/noise-channels/#Noise-Channels","page":"Noise channels","title":"Noise Channels","text":"In addition to unitary quantum gates, realistic quantum circuits must also account for noise.\n\nNoise processes are mathematically described by quantum channels, which generalize unitary evolution and allow non-unitary dynamics such as decoherence and relaxation.\n\nIn MyJuliVQC, quantum channels are represented using the Kraus operator formalism, providing a flexible and unified way to model general noisy processes.\n\n","category":"section"},{"location":"manual/noise-channels/#Defining-General-Quantum-Channels","page":"Noise channels","title":"Defining General Quantum Channels","text":"MyJuliVQC offers a universal constructor:\n\nQuantumMap(positions, kraus)\n\nwhere:\n\npositions specifies the qubits on which the channel acts (e.g., (1,), (2, 3));\nkraus is a vector of matrices\n\n<div align=\"center\"> { K<sub>ℓ</sub> } </div>\n\nrepresenting the channel through\n\n<div align=\"center\"> ρ ↦ ∑<sub>ℓ</sub> K<sub>ℓ</sub> ρ K<sub>ℓ</sub><sup>†</sup>. </div>\n\nThis interface allows the user to define arbitrary custom noise models, from single-qubit decoherence to multi-qubit correlated channels.\n\nExample (defining a custom single-qubit channel):\n\nusing MyJuliVQC\n\nK1 = [1 0; 0 sqrt(0.8)]\nK2 = [0 sqrt(0.2); 0 0]\n\nmy_channel = QuantumMap(1, [K1, K2])   \n\n","category":"section"},{"location":"manual/noise-channels/#Built-in-Noise-Channels","page":"Noise channels","title":"Built-in Noise Channels","text":"For convenience, MyJuliVQC provides several commonly used single-qubit quantum channels as simple wrappers of QuantumMap. These include:\n\nAmplitudeDamping(pos; γ)\nPhaseDamping(pos; γ)\nDepolarizing(pos; p)\n\nEach constructor automatically generates the corresponding Kraus operators and returns a QuantumMap. (Internally, these functions do not use any hardware-specific optimizations; they are implemented in a clean and transparent way suitable for research and educational use.)\n\nExample:\n\nusing MyJuliVQC\n\nchannel = AmplitudeDamping(1; γ=0.1)\nchannelb = PhaseDamping(2; γ=0.2)\nchannelc = Depolarizing(3; p=0.3)","category":"section"},{"location":"examples/utilities/#Utilities","page":"Utility Functions","title":"Utilities","text":"The following utility functions are provided by MyJuliVQC.jl to make it easier to inspect and manipulate variational circuits:\n\nactive_parameters(circ::QCircuit)\nreset_parameters!(circ::QCircuit, coeffs::AbstractVector{<:Number})\nfuse_gates(circ::QCircuit) :: QCircuit\n\nactive_parameters(circ::QCircuit)   Returns a Vector{Float64} containing all active (trainable) parameters in the circuit.   Active parameters correspond to gates constructed with isparas = true.   The order of parameters in this vector matches the internal left-to-right traversal of circ.\nreset_parameters!(circ::QCircuit, coeffs::AbstractVector{<:Number})   Overwrites all active parameters in circ using the entries of coeffs.   Useful for:\ninserting a new parameter vector (e.g., produced by an optimizer),\nscanning over parameter values,\nevaluating the circuit at different parameter sets.  \nThe length of coeffs must match length(active_parameters(circ)).\nfuse_gates(circ::QCircuit) :: QCircuit   Performs a preliminary noiseless simplification of the circuit.   If a single-qubit gate is adjacent to a two-qubit gate and acts on one of its qubits, it is absorbed into the two-qubit gate by matrix multiplication.   Key points:\nOnly applies to noiseless circuits (no QuantumMap allowed).\nAbsorption is local and adjacency-based (left and/or right neighbor).\nA fused two-qubit gate becomes a general QuantumGate with an updated 4×4 matrix.\nIntended as a light-weight preprocessing step before simulation or training.\n\nThese utilities support common workflows such as:\n\nextracting the optimization parameter vector,\npushing updated parameters back into the circuit,\noptionally simplifying circuits prior to simulation.\n\nThey collectively make MyJuliVQC more convenient for variational algorithms, VQE/VQC experiments, and custom optimization routines.","category":"section"},{"location":"manual/initialize-state/#Initialize-State","page":"Initialize a quantum state","title":"Initialize State","text":"The first step in using MyJuliVQC for quantum circuit simulation is to initialize a quantum state represented as a state vector. MyJuliVQC provides two constructors: StateVector for pure states and DensityMatrix for mixed states. \n\nFrom a mathematical viewpoint:\n\nAn n-qubit pure state should be understood as a a vector of size 2^n, corresponding to a rank-n tensor with each index of dimension 2.\nAn n-qubit mixed state is represented as a density matrix of size 2^n2^n, which can be viewed as a rank-2n tensor where each dimension also has size 2.\n\nInternal index conventions:\n\nFor pure states, qubits are internally labeled from 1 to n.\nFor mixed states, the ket indices are labeled from 1 to n, and the corresponding bra indices from n+1 to 2n.\n\nBoth state representations use column-major storage, meaning lower-index dimensions vary fastest.\n\nThese implementation details are generally irrelevant to typical users unless direct access to the raw data is required.\n\nusing MyJuliVQC\n\n# Initialize |00⟩ for 2 qubits\nstate = StateVector(2)\n\nn = 2\npure_state  = StateVector(n)\nmixed_state = DensityMatrix(n)\n\n# Custom pure state (user-specified vector)\ncustom_pure_state = StateVector([0.0, 0.1, 0.0, 0.0])\n\n# Custom mixed state (user-specified flattened matrix)\n# NOTE:\n#   If a vector is used to construct a DensityMatrix,\n#   **the vector must follow column-major (column-first) order**.\n#   That is, the matrix is flattened by stacking all columns in sequence.\ncustom_mixed_state = DensityMatrix([0.5, -0.5im, 0.5im, 0.5]) #column-major order)\n\n# -------------------------------------------------------\n# Construct an equivalent mixed state using a 2×2 matrix\n# -------------------------------------------------------\n\n# 2×2 density matrix explicitly written\nρmat = [\n    0.5      0.5im;\n   -0.5im    0.5\n]\n\n# Construct DensityMatrix from matrix form\nmixed_state_from_matrix = DensityMatrix(ρmat)\n\n# -------------------------------------------------------\n# Test equivalence\n# -------------------------------------------------------\n\nprintln(\"custom_mixed_state data = \", custom_mixed_state.data)\nprintln(\"mixed_state_from_matrix data = \", mixed_state_from_matrix.data)\n\n# They should match element-wise\nprintln(\"Are the two density matrices equal? \",\n        custom_mixed_state.data ≈ mixed_state_from_matrix.data)\n","category":"section"},{"location":"manual/threading-control/#Threading-Control-(MyJuliVQC-Extension)","page":"Threading control (MyJuliVQC)","title":"Threading Control (MyJuliVQC Extension)","text":"MyJuliVQC provides an optional threading-control interface that gives users more flexibility than the original JuliVQC implementation. It allows fine-grained control over how parallelism is applied during quantum-state evolution, which is important for large circuits or multi-core/HPC environments.\n\nThe configuration is done through:\n\nMyJuliVQC.set_threading!(;\n    outer_threads = true,\n    dloc_threshold = 8,\n    blas_threads = nothing,\n)\n\nThis document explains:\n\nwhat each threading parameter means,\nhow MyJuliVQC applies threading internally,\ninteraction with BLAS-level threading,\nrecommended settings for laptops, workstations, and HPC clusters.\n\n","category":"section"},{"location":"manual/threading-control/#Global-Threading-Strategy","page":"Threading control (MyJuliVQC)","title":"Global Threading Strategy","text":"MyJuliVQC uses two potential sources of parallelism:\n\nOuter-level threading   When applying small gates (1–2 qubits) to a large state vector, MyJuliVQC may distribute the work across Julia threads. This is also used for some density-matrix kernels.\nBLAS-level threading   Some operations, especially involving large density matrices, rely on BLAS routines (MKL, OpenBLAS, etc.), which may themselves use multi-threading internally.\n\nUsing both at once may cause oversubscription. The function set_threading! helps control this balance.\n\n","category":"section"},{"location":"manual/threading-control/#Configuration-Interface","page":"Threading control (MyJuliVQC)","title":"Configuration Interface","text":"","category":"section"},{"location":"manual/threading-control/#Parameter:-outer_threads","page":"Threading control (MyJuliVQC)","title":"Parameter: outer_threads","text":"Controls whether MyJuliVQC uses Julia-level Threads.@threads for gate-application loops.\n\nouter_threads = true    # enable outer-level parallel loops\nouter_threads = false   # disable outer-level parallelism\n\nSituations where setting this to false is beneficial:\n\nwhen BLAS is using many threads,\nwhen oversubscription occurs,\nwhen benchmarking indicates BLAS dominates performance.\n\n","category":"section"},{"location":"manual/threading-control/#Parameter:-dloc_threshold","page":"Threading control (MyJuliVQC)","title":"Parameter: dloc_threshold","text":"Controls when outer threading is allowed.\n\ndloc = local dimension of a gate = 2^k for a k-qubit gate.\nIf dloc <= dloc_threshold, MyJuliVQC may activate outer threading.\n\nExample meanings:\n\ndloc_threshold = 8    # allow threading for gates up to 3 qubits\ndloc_threshold = 4    # allow threading only for 1–2 qubit gates\n\n","category":"section"},{"location":"manual/threading-control/#Parameter:-blas_threads","page":"Threading control (MyJuliVQC)","title":"Parameter: blas_threads","text":"Optional argument to configure BLAS:\n\nblas_threads = N       # attempt to set BLAS to use N threads\nblas_threads = nothing # leave BLAS thread count unchanged (default)\n\nSome BLAS installations may not support runtime thread changes; MyJuliVQC silently ignores errors in such cases.\n\nSetting blas_threads = 1 is often useful if relying mostly on Julia threads.\n\n","category":"section"},{"location":"manual/threading-control/#Example-Usage","page":"Threading control (MyJuliVQC)","title":"Example Usage","text":"using MyJuliVQC\n\nMyJuliVQC.set_threading!(;\n    outer_threads = true,\n    dloc_threshold = 8,\n    blas_threads = 1,\n)\n\nThis configuration:\n\nenables outer-level threading,\napplies it to small gates,\nrestricts BLAS to a single thread.\n\n","category":"section"},{"location":"manual/threading-control/#Internal-Usage","page":"Threading control (MyJuliVQC)","title":"Internal Usage","text":"MyJuliVQC stores configuration using:\n\n_USE_OUTER_THREADS[]        # reflective boolean flag\n_DLOC_THREAD_THRESHOLD[]    # integer threshold for small gates\n\nand provides internal helper functions:\n\nuse_outer_threads()\ndloc_thread_threshold()\n\nThese are not exported, but used by the kernel implementation.\n\n","category":"section"},{"location":"manual/threading-control/#Recommended-Configurations","page":"Threading control (MyJuliVQC)","title":"Recommended Configurations","text":"","category":"section"},{"location":"manual/threading-control/#Laptops-(4–8-cores)","page":"Threading control (MyJuliVQC)","title":"Laptops (4–8 cores)","text":"set_threading!(;\n    outer_threads = true,\n    dloc_threshold = 8,\n    blas_threads = 1,\n)","category":"section"},{"location":"manual/threading-control/#Workstations-(16–32-cores)","page":"Threading control (MyJuliVQC)","title":"Workstations (16–32 cores)","text":"set_threading!(;\n    outer_threads = true,\n    dloc_threshold = 12,\n    blas_threads = 4,\n)","category":"section"},{"location":"manual/threading-control/#HPC-Nodes-(32–128-cores)","page":"Threading control (MyJuliVQC)","title":"HPC Nodes (32–128+ cores)","text":"set_threading!(;\n    outer_threads = false,\n    dloc_threshold = 16,\n    blas_threads = 16,\n)\n\nHPC nodes typically benefit from strong BLAS kernels rather than Julia-threaded outer loops.\n\n","category":"section"},{"location":"manual/threading-control/#Notes","page":"Threading control (MyJuliVQC)","title":"Notes","text":"MyJuliVQC does not yet include specialized gate kernels like the original JuliVQC, so threading strategy can significantly affect performance.\nUsers should benchmark real workloads to determine optimal settings.\nFuture versions may include adaptive heuristics for automatically balancing Julia-level and BLAS-level threading.","category":"section"},{"location":"getting-started/quick-start/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"This page provides a short hands-on introduction to MyJuliVQC, showing how to construct, apply, and differentiate variational quantum circuits.\n\n","category":"section"},{"location":"getting-started/quick-start/#Example-1:-Preparing-a-Bell-State","page":"Quick Start","title":"Example 1: Preparing a Bell State","text":"The following script initializes a 2-qubit state, applies a simple quantum circuit, and performs a measurement:\n\nusing MyJuliVQC\n\n# Create a 2-qubit state |00⟩\nψ = StateVector(2)\n\n# Build a quantum circuit\ncircuit = QCircuit()\npush!(circuit, HGate(1))          # Hadamard on qubit 1\npush!(circuit, CNOTGate(1, 2))    # Controlled-NOT from qubit 1 to 2\n\n# Apply the circuit to the state\napply!(circuit, ψ)\n\n# Inspect the resulting state\nprintln(\"Final state vector:\")\nprintln(ψ)\n\n# Measure qubit 1\noutcome, prob = measure!(ψ, 1)\nprintln(\"Measured qubit 1 → $outcome   (probability = $prob)\")\n\n","category":"section"},{"location":"getting-started/quick-start/#Example-2:-A-Simple-Variational-Circuit","page":"Quick Start","title":"Example 2: A Simple Variational Circuit","text":"This example shows how to construct a parameterized circuit and evaluate a loss function:\n\nusing MyJuliVQC\nconst gradientMJVQC = MyJuliVQC.gradient\n\n# 1. initial state\nL  = 3                      # number of qubits\nψ0 = StateVector(L)         # |000⟩\n\n# 2. construct a simple variational circuit\ncircuit = QCircuit()\n\n# Layer 1: single-qubit rotations\nfor i in 1:L\n    push!(circuit, RzGate(i, rand(), isparas=true))\n    push!(circuit, RyGate(i, rand(), isparas=true))\n    push!(circuit, RzGate(i, rand(), isparas=true))\nend\n\n# Layer 2: entangling + rotations\nfor i in 1:L-1\n    push!(circuit, CNOTGate(i, i+1))\nend\nfor i in 1:L\n    push!(circuit, RxGate(i, rand(), isparas=true))\nend\n\n# 3. define a simple operator H\nH = QubitsOperator([QubitsTerm(1=>\"Z\", 2=>\"Z\", 3=>\"Z\"; coeff=1.0)])\n\n# 4. construct the loss\nloss_obj = LossExpectationRealSV(H, ψ0)\n\n# 5. compute the loss(expectation) with the current circuit\nprintln(\"Expectation value (loss) = \", loss_obj(circuit))\n\n# 6. use gradient to get the gradient\ngrads = gradientMJVQC(loss_obj, circuit)\nprintln(\"Gradient from MyJuliVQC.gradient:\")\nprintln(grads)\n\n\n","category":"section"},{"location":"manual/automatic-differentiation/#Automatic-Differentiation","page":"Automatic differentiation","title":"Automatic Differentiation","text":"MyJuliVQC provides transparent support for automatic differentiation (AD) of variational quantum circuits. The core idea is:\n\nConstruct a parameterized circuit circ::QCircuit.\nDefine a loss based on an observable expectation value.\nUse the specialized gradient API to obtain derivatives with respect to all active parameters in the circuit.\n\nInternally, MyJuliVQC implements a custom, hand-written backward pass for expectation values, integrated with Zygote, for both:\n\nstate-vector simulations (StateVector), and\ndensity-matrix simulations (DensityMatrix, i.e. noisy circuits).\n\nThis is built around two lightweight loss types:\n\nLossExpectationRealSV – for pure states (state vectors).\nLossExpectationRealDM – for mixed states (density matrices).\n\nThese types are backed by a two-state reverse-mode algorithm that avoids materializing full 2ⁿ × 2ⁿ matrices.\n\n","category":"section"},{"location":"manual/automatic-differentiation/#High-Level-Usage","page":"Automatic differentiation","title":"High-Level Usage","text":"","category":"section"},{"location":"manual/automatic-differentiation/#Step-1-–-Build-a-circuit-and-an-operator","page":"Automatic differentiation","title":"Step 1 – Build a circuit and an operator","text":"You first construct:\n\na parameterized circuit: circ::QCircuit, and\na qubit operator: op::QubitsOperator (e.g. a Hamiltonian).\n\nYou also choose an initial state: either a StateVector or DensityMatrix.\n\nusing MyJuliVQC\n\nfunction heisenberg_1d(L; hz = 1.0, J = 1.0)\n    terms = QubitsTerm[]\n\n    # Local Z fields\n    for i in 1:L\n        push!(terms, QubitsTerm(i => \"Z\"; coeff = hz))\n    end\n\n    # Nearest-neighbor interactions: X X + Y Y + Z Z\n    for i in 1:L-1\n        push!(terms, QubitsTerm(i => \"X\", i+1 => \"X\"; coeff = J))\n        push!(terms, QubitsTerm(i => \"Y\", i+1 => \"Y\"; coeff = J))\n        push!(terms, QubitsTerm(i => \"Z\", i+1 => \"Z\"; coeff = J))\n    end\n\n    return QubitsOperator(terms)\nend\n\nL = 3\nψ0 = StateVector(L)       # |000⟩\nH  = heisenberg_1d(L)     # user-defined helper that builds a QubitsOperator","category":"section"},{"location":"manual/automatic-differentiation/#Step-2-–-Wrap-the-loss-using-LossExpectationRealSV-/-LossExpectationRealDM","page":"Automatic differentiation","title":"Step 2 – Wrap the loss using LossExpectationRealSV / LossExpectationRealDM","text":"For pure-state simulations:\n\ncirc = QCircuit()\nfor i in 1:2\n    push!(circ, CNOTGate(i, i+1))\nend\nfor i in 1:3\n    push!(circ, RyGate(i, randn(); isparas=true))\nend\n\nloss_obj = LossExpectationRealSV(H, ψ0)\n\n# This object is callable: loss_obj(circ) = real(⟨ψ0| C(θ)† H C(θ) |ψ0⟩)\nval = loss_obj(circ)\nprintln(\"Loss value = \", val)\n\nFor density-matrix simulations (e.g. noisy circuits):\n\nρ0 = DensityMatrix(L)\nloss_dm = LossExpectationRealDM(H, ρ0)\n\nval_dm = loss_dm(circ)\nprintln(\"Loss (density-matrix) = \", val_dm)","category":"section"},{"location":"manual/automatic-differentiation/#Step-3-–-Compute-gradients-w.r.t.-circuit-parameters","page":"Automatic differentiation","title":"Step 3 – Compute gradients w.r.t. circuit parameters","text":"MyJuliVQC provides specialized overloads of gradient:\n\nusing MyJuliVQC\nconst gradientMJVQC = MyJuliVQC.gradient\n\ngrads = gradientMJVQC(loss_obj, circ)\nprintln(\"Gradient vector = \", grads)\n\nThe result is a Vector{Float64} ordered consistently with:\n\nθ = active_parameters(circ)\n\nYou can then perform a parameter update, for example via gradient descent:\n\nα = 0.01\nθ  = active_parameters(circ)\nθ_new = θ .- α .* grads\nreset_parameters!(circ, θ_new)\n\n","category":"section"},{"location":"manual/automatic-differentiation/#Example:-Variational-Energy-Minimization-(Pure-State)","page":"Automatic differentiation","title":"Example: Variational Energy Minimization (Pure State)","text":"Below is a more complete example of a simple variational ansatz with MyJuliVQC’s automatic differentiation.\n\nusing MyJuliVQC\n\nconst gradientMJVQC = MyJuliVQC.gradient\n\n# 1. problem setup\nL  = 3\nψ0 = StateVector(L)\nfunction heisenberg_1d(L; hz = 1.0, J = 1.0)\n    terms = QubitsTerm[]\n\n    # Local Z fields\n    for i in 1:L\n        push!(terms, QubitsTerm(i => \"Z\"; coeff = hz))\n    end\n\n    # Nearest-neighbor interactions: X X + Y Y + Z Z\n    for i in 1:L-1\n        push!(terms, QubitsTerm(i => \"X\", i+1 => \"X\"; coeff = J))\n        push!(terms, QubitsTerm(i => \"Y\", i+1 => \"Y\"; coeff = J))\n        push!(terms, QubitsTerm(i => \"Z\", i+1 => \"Z\"; coeff = J))\n    end\n\n    return QubitsOperator(terms)\nend\n\nH  = heisenberg_1d(L; hz = 1.0, J = 1.0)\n\n# 2. build a parameterized circuit\ncirc = QCircuit()\nn_layers = 2\n\nfor layer in 1:n_layers\n    # entangling pattern\n    for i in 1:L-1\n        push!(circ, CNOTGate(i, i+1))\n    end\n    # local rotations\n    for i in 1:L\n        push!(circ, RyGate(i, randn(); isparas = true))\n        push!(circ, RxGate(i, randn(); isparas = true))\n    end\nend\n\n# 3. wrap loss using LossExpectationRealSV\nloss_obj = LossExpectationRealSV(H, ψ0)\n\n# 4. evaluate loss and gradient\nE = loss_obj(circ)\nprintln(\"Initial energy = \", E)\n\ng = gradientMJVQC(loss_obj, circ)\nprintln(\"Gradient vector length = \", length(g))\n\n# 5. gradient descent update\nα = 0.05\nθ  = active_parameters(circ)\nθ_new = θ .- α .* g\nreset_parameters!(circ, θ_new)\n\nE_new = loss_obj(circ)\nprintln(\"Energy after one GD step = \", E_new)\n\n","category":"section"},{"location":"manual/automatic-differentiation/#Example:-Variational-Optimization-with-Noise-(Density-Matrix)","page":"Automatic differentiation","title":"Example: Variational Optimization with Noise (Density Matrix)","text":"For noisy circuits, you only need to replace the state with a density matrix and use LossExpectationRealDM:\n\nusing MyJuliVQC\n\nconst gradientMJVQC = MyJuliVQC.gradient\n\nL  = 2\nρ0 = DensityMatrix(L)\nfunction heisenberg_1d(L; hz = 1.0, J = 1.0)\n    terms = QubitsTerm[]\n\n    # Local Z fields\n    for i in 1:L\n        push!(terms, QubitsTerm(i => \"Z\"; coeff = hz))\n    end\n\n    # Nearest-neighbor interactions: X X + Y Y + Z Z\n    for i in 1:L-1\n        push!(terms, QubitsTerm(i => \"X\", i+1 => \"X\"; coeff = J))\n        push!(terms, QubitsTerm(i => \"Y\", i+1 => \"Y\"; coeff = J))\n        push!(terms, QubitsTerm(i => \"Z\", i+1 => \"Z\"; coeff = J))\n    end\n\n    return QubitsOperator(terms)\nend\n\nH  = heisenberg_1d(L)\n\ncirc = QCircuit()\npush!(circ, HGate(1))\npush!(circ, Depolarizing(1;p=0.05))\npush!(circ, RxGate(1, 0.3; isparas = true))\npush!(circ, CNOTGate(1, 2))\n\nloss_dm = LossExpectationRealDM(H, ρ0)\n\nE = loss_dm(circ)\nprintln(\"Noisy loss = \", E)\n\ng = gradientMJVQC(loss_dm, circ)\nprintln(\"Gradient (noisy case) = \", g)\n\n","category":"section"},{"location":"manual/automatic-differentiation/#Practical-Notes-and-Limitations","page":"Automatic differentiation","title":"Practical Notes and Limitations","text":"Currently, MyJuliVQC only supports gradients for losses constructed using LossExpectationRealSV and LossExpectationRealDM.\nThese two loss types correspond to expectation-based objectives of the form   Re(⟨ψ| C(θ)† H C(θ) |ψ⟩) for pure states and   Re(Tr[ H C(θ) ρ C(θ)† ]) for density matrices.\nAny other form of loss function (e.g., fidelity loss, distance-based loss, norm penalties, custom metric functions, etc.) is not yet supported by   MyJuliVQC.gradient. Attempting to call gradient(loss, circ) on such losses will not work.\nFull AD support for arbitrary loss functions may be added in a future version\n\nof MyJuliVQC.\n\n","category":"section"},{"location":"manual/automatic-differentiation/#Summary","page":"Automatic differentiation","title":"Summary","text":"MyJuliVQC provides custom AD support for expectation values using LossExpectationRealSV and LossExpectationRealDM.\nThe public API is:\nloss_obj = LossExpectationRealSV(op, ψ0)\ngrads    = gradient(loss_obj, circ)\n(and analogously for LossExpectationRealDM).\nGradients are returned as a Vector{Float64} aligned with active_parameters(circ) and can be directly used in gradient-based optimization loops for VQE, variational classifiers, and other hybrid quantum–classical algorithms.","category":"section"},{"location":"manual/qubit-operators/#Qubit-Operators","page":"Qubit operators","title":"Qubit Operators","text":"In MyJuliVQC, multi-qubit observables and Hamiltonians are represented using two closely related types:\n\nQubitsTerm – a single Pauli-string–style term (or more generally, a product of one-qubit operators with a scalar coefficient).\nQubitsOperator – a container holding a sum of QubitsTerm objects.\n\nThis design provides a flexible way to build spin Hamiltonians, tensor-product observables, and general operators needed in variational quantum algorithms.\n\nOnce a QubitsOperator op has been constructed, its expectation value on a state (either StateVector or DensityMatrix) can be computed with:\n\nexpectation(op, state)\n\n(implemented in a separate file; not in qubits_term.jl / qubitsoperator.jl directly).\n\n","category":"section"},{"location":"manual/qubit-operators/#QubitsTerm:-Single-Term-Representation","page":"Qubit operators","title":"QubitsTerm: Single-Term Representation","text":"A QubitsTerm represents a single product of local operators acting on specific qubits.","category":"section"},{"location":"manual/qubit-operators/#Accessors","page":"Qubit operators","title":"Accessors","text":"There are basic operations:\n\ncopy(t::QubitsTerm)\nisempty(t::QubitsTerm)\nadjoint(t::QubitsTerm)        # Hermitian conjugate (†), conjugating coeff and local matrices\n3 * t                         # scalar multiplication (left or right)\nBase.eltype(t::QubitsTerm)    # promoted numeric element type\n\n","category":"section"},{"location":"manual/qubit-operators/#Constructing-QubitsTerm","page":"Qubit operators","title":"Constructing QubitsTerm","text":"Several convenience constructors are provided.","category":"section"},{"location":"manual/qubit-operators/#1.-From-explicit-vectors","page":"Qubit operators","title":"1. From explicit vectors","text":"QubitsTerm(pos::Vector{Int}, m::Vector, v::Number)\nQubitsTerm(pos::Tuple,       m::Vector, v::Number)\n\nExample:\n\nusing MyJuliVQC\n\npos = [2, 1]\nops = [\"X\", \"Z\"]    # will be mapped to matrices via _op_mapping\nt   = QubitsTerm(pos, ops, 0.5)\n\nInternally, pos and ops are normalized to ascending qubit order using an internal helper _get_normal_order, so the canonical representation is on qubits [1, 2].","category":"section"},{"location":"manual/qubit-operators/#2.-From-a-dictionary","page":"Qubit operators","title":"2. From a dictionary","text":"QubitsTerm(x::AbstractDict{Int}; coeff::Number = 1.0)\n\nkeys: Int (1-based qubit indices),\nvalues: either strings (\"X\", \"Z\", …) or explicit 2×2 matrices.\n\nExample:\n\nusing MyJuliVQC\n\nt = QubitsTerm(Dict(1 => \"X\", 3 => \"Y\"); coeff = 2.0)\n\nInternally, the dictionary is decomposed by dict_to_site_ops into (sites, ops) and passed to the main constructor.","category":"section"},{"location":"manual/qubit-operators/#3.-From-pairs","page":"Qubit operators","title":"3. From pairs","text":"This is often the most convenient syntax in user code:\n\nQubitsTerm(i1 => op1, i2 => op2, ...; coeff::Number = 1.0)\n\nEach pair uses:\n\nkey: Int for the qubit index.\nvalue: either\nan AbstractString (e.g. \"X\", \"Y\", \"Z\", \"I\", \"+\", \"-\", \"u\", \"d\", \"0\", \"1\"), or\nan AbstractMatrix (typically a 2×2 matrix).\n\nThese symbolic labels are mapped to matrices using the internal _op_mapping table:\n\nconst _op_mapping = Dict(\n    \"X\" => [0. 1.; 1. 0.],\n    \"Y\" => [0. -im; im 0.],\n    \"Z\" => [1. 0.; 0. -1.],\n    \"+\" => [0. 1.; 0. 0.],\n    \"-\" => [0. 0.; 1. 0.],\n    \"I\" => [1. 0.; 0. 1.],\n    \"u\" => [1. 0.; 0. 0.],\n    \"d\" => [0. 0.; 0. 1.],\n    \"0\" => [1. 0.; 0. 0.],\n    \"1\" => [0. 0.; 0. 1.],\n)\n\nExamples:\n\nusing MyJuliVQC\n\n# Using string operators\nt1 = QubitsTerm(1 => \"X\", 3 => \"Y\"; coeff = 0.5)\n\n# Using explicit matrices\nσx = [0. 1.; 1. 0.]\nt2 = QubitsTerm(2 => σx, 4 => \"Z\"; coeff = 1.0 + 0.0im)\n\n# Equivalent to constructing from Dict\nt3 = QubitsTerm(Dict(1 => \"X\", 3 => \"Y\"); coeff = 0.5)\n\nNotes:\n\nAll pairs are collected into a Dict first and then normalized to ascending qubit order.\nIf duplicate indices appear, the last one wins (dictionary semantics).\n\n","category":"section"},{"location":"manual/qubit-operators/#QubitsOperator:-Sum-of-Terms","page":"Qubit operators","title":"QubitsOperator: Sum of Terms","text":"QubitsOperator is a container for a sum of QubitsTerm, representing a Hamiltonian or general observable.","category":"section"},{"location":"manual/qubit-operators/#Constructors","page":"Qubit operators","title":"Constructors","text":"QubitsOperator()                      # empty operator\nQubitsOperator(t1, t2, ...)          # from varargs QubitsTerm\nQubitsOperator(ts::Vector{<:QubitsTerm})\nQubitsOperator(ts::AbstractVector)   # will be collected as Vector{QubitsTerm}\n\nExample:\n\nusing MyJuliVQC\n\nop = QubitsOperator()\npush!(op, QubitsTerm(1 => \"X\", 2 => \"Z\"; coeff = 0.5))","category":"section"},{"location":"manual/qubit-operators/#Collection-like-interface","page":"Qubit operators","title":"Collection-like interface","text":"length(op::QubitsOperator)\nisempty(op::QubitsOperator)\ngetindex(op::QubitsOperator, i::Int)\niterate(op::QubitsOperator)\ncopy(op::QubitsOperator)\npush!(op::QubitsOperator, t::QubitsTerm)\n\nYou can also inspect it via show:\n\nprintln(op)\n# QubitsOperator with N term(s):\n#  [1] positions = ..., coeff = ...","category":"section"},{"location":"manual/qubit-operators/#Algebraic-operations","page":"Qubit operators","title":"Algebraic operations","text":"adjoint(op::QubitsOperator)    # term-wise Hermitian conjugate\nλ * op                         # scalar multiplication\nop * λ                         # scalar multiplication (commutative)\nA + B                          # concatenation of terms from A and B\n\n","category":"section"},{"location":"manual/qubit-operators/#Simplification:-simplify!","page":"Qubit operators","title":"Simplification: simplify!","text":"simplify!(op::QubitsOperator)\n\nThis in-place operation:\n\nmerges terms having the same positions and the same sequence of local matrices (tested via an exact string-based key), and\nreplaces them with a single term whose coefficient is the sum of the original coefficients.\n\nInternally, it builds a Dict{String,QubitsTerm} keyed by a serialization of:\n\nthe positions vector,\nand the flattened matrices in oplist(t).\n\nThis is robust for canonical Pauli-string terms constructed via \"X\", \"Y\", etc., because their matrices are fixed. However:\n\nIf the user supplies slightly different but mathematically equivalent matrices (e.g. [0 1; 1 0] vs [0.0 1.0; 1.0 0.0]), they may not be merged, since the string representations differ.\n\nTypical usage:\n\nusing MyJuliVQC\nop = QubitsOperator(\n    QubitsTerm(1=>\"X\", 2=>\"X\"; coeff=1.0),\n    QubitsTerm(1=>\"X\", 2=>\"X\"; coeff=2.0),\n)\n\nsimplify!(op)\n# Now op has a single term with coeff = 3.0\n\n","category":"section"},{"location":"manual/qubit-operators/#Example:-1D-Heisenberg-Hamiltonian","page":"Qubit operators","title":"Example: 1D Heisenberg Hamiltonian","text":"The following function builds a standard 1D Heisenberg Hamiltonian on L qubits:\n\nusing MyJuliVQC\n\nfunction heisenberg_1d(L; hz = 1.0, J = 1.0)\n    terms = QubitsTerm[]\n\n    # Local Z fields\n    for i in 1:L\n        push!(terms, QubitsTerm(i => \"Z\"; coeff = hz))\n    end\n\n    # Nearest-neighbor interactions: X X + Y Y + Z Z\n    for i in 1:L-1\n        push!(terms, QubitsTerm(i => \"X\", i+1 => \"X\"; coeff = J))\n        push!(terms, QubitsTerm(i => \"Y\", i+1 => \"Y\"; coeff = J))\n        push!(terms, QubitsTerm(i => \"Z\", i+1 => \"Z\"; coeff = J))\n    end\n\n    return QubitsOperator(terms)\nend\n\nYou can then use this operator with expectation:\n\nψ = StateVector(3)\nH = heisenberg_1d(3)\nE = expectation(H, ψ)\nprintln(\"⟨ψ|H|ψ⟩ = \", E)\n\nFor mixed states:\n\nρ = DensityMatrix(3)\nEρ = expectation(H, ρ)\nprintln(\"Tr(ρ H) = \", Eρ)\n\n","category":"section"},{"location":"manual/qubit-operators/#Summary","page":"Qubit operators","title":"Summary","text":"QubitsTerm encodes a single Pauli-string–like term with a scalar coefficient.\nQubitsOperator is a sum of such terms, suitable for Hamiltonians and observables.\nConstructors accept vectors, dictionaries, and i => op pairs, with string labels mapped to predefined 2×2 matrices.\nsimplify! merges identical terms by summing coefficients.\nThese structures integrate naturally with expectation(op, state) and the variational/gradient engine in MyJuliVQC.","category":"section"},{"location":"examples/gd-example/#Gradient-Descent-Example","page":"A Simple Application of Gradient Descent","title":"Gradient-Descent Example","text":"This example shows how to integrate a variational quantum circuit built with MyJuliVQC into a simple gradient-descent training loop.   We optimize the parameters of a VQC to minimize the expectation value of a Hamiltonian, which is the standard setting in VQE-type algorithms.\n\nUnlike the original JuliVQC example that uses Flux.Optimise, here we use a plain hand-written gradient descent loop driven by MyJuliVQC.gradient.   This makes the example self-contained and easy to run without extra dependencies.\n\nusing MyJuliVQC\n\nconst gradientMJVQC = MyJuliVQC.gradient\n\n# -----------------------------\n# 1. Problem setup\n# -----------------------------\nL      = 3                    # number of qubits\ndepth  = 2                    # circuit depth\nψ0     = StateVector(L)       # initial state |000⟩\n\n# Simple 1D Heisenberg Hamiltonian as QubitsOperator:\n#   H = ∑_i hz * Z_i + ∑_i J * (X_i X_{i+1} + Y_i Y_{i+1} + Z_i Z_{i+1})\nfunction heisenberg_1d(L; hz = 1.0, J = 1.0)\n    terms = QubitsTerm[]\n\n    # Local Z fields\n    for i in 1:L\n        push!(terms, QubitsTerm(i => \"Z\"; coeff = hz))\n    end\n\n    # Nearest-neighbor interactions: X X + Y Y + Z Z\n    for i in 1:L-1\n        push!(terms, QubitsTerm(i => \"X\", i+1 => \"X\"; coeff = J))\n        push!(terms, QubitsTerm(i => \"Y\", i+1 => \"Y\"; coeff = J))\n        push!(terms, QubitsTerm(i => \"Z\", i+1 => \"Z\"; coeff = J))\n    end\n\n    return QubitsOperator(terms)\nend\n\nH = heisenberg_1d(L)     # user-defined Hamiltonian as QubitsOperator\n\n# -----------------------------\n# 2. Build a variational circuit\n# -----------------------------\ncircuit = QCircuit()\n\n# First layer: local rotations\nfor i in 1:L\n    push!(circuit, RzGate(i, rand(); isparas = true))\n    push!(circuit, RyGate(i, rand(); isparas = true))\n    push!(circuit, RzGate(i, rand(); isparas = true))\nend\n\n# Repeated entangling + rotations\nfor l in 1:depth\n    # entangling chain\n    for i in 1:L-1\n        push!(circuit, CNOTGate(i, i+1))\n    end\n    # another layer of local rotations\n    for i in 1:L\n        push!(circuit, RzGate(i, rand(); isparas = true))\n        push!(circuit, RxGate(i, rand(); isparas = true))\n        push!(circuit, RzGate(i, rand(); isparas = true))\n    end\nend\n\n# -----------------------------\n# 3. Wrap loss as expectation value\n#    loss(circ) = Re⟨ψ0| C(θ)† H C(θ) |ψ0⟩\n# -----------------------------\nloss_obj = LossExpectationRealSV(H, ψ0)\n\n# Extract initial parameter vector\nθ = active_parameters(circuit)\n\n# -----------------------------\n# 4. Simple gradient-descent loop\n# -----------------------------\nη      = 0.01    # learning rate\nepochs = 10      # number of gradient steps\n\nfor epoch in 1:epochs\n    # gradient of loss w.r.t. all active parameters in `circuit`\n    gθ = gradientMJVQC(loss_obj, circuit)\n\n    # gradient-descent update (in-place on θ)\n    θ .-= η .* gθ\n\n    # write updated parameters back into the circuit\n    reset_parameters!(circuit, θ)\n\n    # monitor current loss\n    current_loss = loss_obj(circuit)\n    println(\"Epoch $epoch: loss = $current_loss\")\nend","category":"section"},{"location":"examples/gd-example/#Explanation-of-the-Workflow","page":"A Simple Application of Gradient Descent","title":"Explanation of the Workflow","text":"","category":"section"},{"location":"examples/gd-example/#1.-Circuit-Construction","page":"A Simple Application of Gradient Descent","title":"1. Circuit Construction","text":"We manually build a parameterized quantum circuit (QCircuit) using   RzGate, RyGate, RxGate, and CNOTGate.   Gates flagged with isparas = true contribute entries to   active_parameters(circuit) which determines the ordering of the parameter   vector θ.","category":"section"},{"location":"examples/gd-example/#2.-Hamiltonian-and-Loss","page":"A Simple Application of Gradient Descent","title":"2. Hamiltonian and Loss","text":"The Hamiltonian H is encoded as a QubitsOperator, here constructed by   heisenberg_1d.\n\nThe loss is the real part of the expectation value\n\n⟨ψ0 | C(θ)† H C(θ) | ψ0⟩ ,\n\nwrapped in a LossExpectationRealSV(H, ψ0) object.\n\nEvaluating loss_obj(circuit) computes this scalar.","category":"section"},{"location":"examples/gd-example/#3.-Gradients-via-MyJuliVQC.gradient","page":"A Simple Application of Gradient Descent","title":"3. Gradients via MyJuliVQC.gradient","text":"MyJuliVQC.gradient provides specialized gradient rules for   LossExpectationRealSV / LossExpectationRealDM, internally performing a   hand-written backward pass combined with Zygote.\n\nCalling\n\ngθ = gradientMJVQC(loss_obj, circuit)\n\nreturns the gradient vector matching the ordering of active_parameters(circuit).","category":"section"},{"location":"examples/gd-example/#4.-Hand-Written-Gradient-Descent","page":"A Simple Application of Gradient Descent","title":"4. Hand-Written Gradient Descent","text":"We perform simple gradient descent:\n\nθ .-= η .* gθ\nreset_parameters!(circuit, θ)\n\nwhich updates the parameter vector and writes it back into the circuit.\n\n","category":"section"},{"location":"examples/gd-example/#Notes-on-Future-Integration-with-Flux-/-Optimisers","page":"A Simple Application of Gradient Descent","title":"Notes on Future Integration with Flux / Optimisers","text":"This example intentionally avoids using Flux.jl or Optimisers.jl so that   it runs in a clean, dependency-free manner.\nThe design (parameter vectors + gradients as plain Vector{Float64}) already   makes MyJuliVQC optimizer-friendly.\nFuture versions of MyJuliVQC may provide deeper native integration with   Flux / Optimisers (e.g. ADAM or other ML optimizers), enabling smoother   hybrid QML–VQC workflows.","category":"section"},{"location":"manual/quantum-gates/#Quantum-Gates","page":"Quantum gates","title":"Quantum Gates","text":"The second step of using MyJuliVQC is to build a quantum circuit, which requires specifying the elementary quantum gate operations (and, for noisy circuits, quantum channels).\n\nThe most general way to define a quantum gate in MyJuliVQC is via the constructor\n\nQuantumGate(positions, data)\n\nwhere:\n\npositions specifies the qubit indices that the gate acts on, e.g. (1, 3) for a two-qubit gate on qubits 1 and 3;\ndata is the raw matrix of the gate, which should be a unitary matrix of size 2^k × 2^k for a k-qubit gate.\n\nInternally, MyJuliVQC uses column-major ordering (Julia’s default) for storing gate matrices and state data.","category":"section"},{"location":"manual/quantum-gates/#Matrix-Element-Convention-for-QuantumGate","page":"Quantum gates","title":"Matrix Element Convention for QuantumGate","text":"More specifically, suppose QuantumGate(positions, data) (where textttpositions = (j_1 j_2 dots j_l)) represents an operator hatO acting on the Hilbert subspace associated with the qubits j_1 j_2 ldots j_l. Let x_j_1=k_1space x_j_2=k_2space cdots space x_j_l=k_lrangle denote a computational basis vector in this Hilbert space. Then $ \\texttt{data}[a,b] = \\langle x{j1}=a1,x{j2}=a2,\\dots,x{jl}=al \\mid \\hat{O} \\mid x{j1}=b1,x{j2}=b2,\\dots,x{jl}=bl \\rangle,$ where ab in 12dots2^l, and the binary expansions of (a-1) and (b-1) correspond to (a_ldotsa_2a_1) and (b_ldotsb_2b_1), respectively.\n\nAs a concrete example, consider a two-qubit controlled gate whose control qubit is the 2nd qubit and target qubit is the 4th qubit. If we take positions = (2,4) then the corresponding data matrix can be written as $ \\texttt{data} = \\begin{pmatrix} 1 & 0 & 0 & 0 \\\n0 & u{11} & 0 & u{12} \\\n0 & 0 & 1 & 0 \\\n0 & u{21} & 0 & u{22} \\end{pmatrix},$ where beginpmatrix u_11  u_12  u_21  u_22 endpmatrix denotes the single-qubit unitary acting on the target qubit when the control qubit takes the value 1.\n\nIf we swap the order of positions, i.e. take positions} = (4,2), then data should instead be written as textttdata = beginpmatrix 1  0  0  0 \n0  1  0  0 \n0  0  u_11  u_12 \n0  0  u_21  u_22 endpmatrix\n\nIf we change the control qubit of this two-qubit controlled gate to be the 4th qubit and the target qubit to be the 2nd qubit, then we may set textttpositions=(42)space textttdata = beginpmatrix 1  0  0  0 \n0  u_11  0  u_12 \n0  0  1  0 \n0  u_21  0  u_22 endpmatrix or textttpositions=(24)space textttdata = beginpmatrix 1  0  0  0 \n0  1  0  0 \n0  0  u_11  u_12 \n0  0  u_21  u_22 endpmatrix\n\n","category":"section"},{"location":"manual/quantum-gates/#Built-in-Quantum-Gates","page":"Quantum gates","title":"Built-in Quantum Gates","text":"For convenience, MyJuliVQC also provides named constructors for commonly used quantum gates:\n\nXGate, YGate, ZGate, SGate, HGate, sqrtXGate, sqrtYGate, TGate, SWAPGate, iSWAPGate, CZGate, CNOTGate, TOFFOLIGate, FREDKINGate, RxGate, RyGate,RzGate, CRxGate, CRyGate, CRzGate, FSIMGate. \n\nIn the current implementation of MyJuliVQC, these special gates are implemented as thin wrappers around the generic QuantumGate constructor. This design keeps the code transparent and easy to read. Future versions may introduce specialized, highly optimized kernels for some of these gates, but the public API will remain the same.\n\n","category":"section"},{"location":"manual/quantum-gates/#Controlled-Gates","page":"Quantum gates","title":"Controlled Gates","text":"MyJuliVQC supports generic controlled operations via dedicated constructors:\n\nCONTROLGate(i, j, data): a controlled single-qubit gate  \ni: control qubit  \nj: target qubit  \ndata: the 2×2 matrix of the target single-qubit operation\nCONTROLCONTROLGate(i, j, k, data): a doubly controlled single-qubit gate  \ni, j: control qubits  \nk: target qubit  \ndata: again the 2×2 matrix acting on the target qubit\n\nThese constructors are convenient when you want to promote an arbitrary single-qubit gate to a (multi-)controlled version without manually building the full 2^n × 2^n matrix.\n\n","category":"section"},{"location":"manual/quantum-gates/#Parametric-Quantum-Gates","page":"Quantum gates","title":"Parametric Quantum Gates","text":"Many variational algorithms require parameterized gates.   In MyJuliVQC, such gates follow a unified interface\n\nG(i..., paras; isparas)\n\nwhere:\n\nG is a gate constructor such as RxGate, RyGate, RzGate, FSIMGate, etc.;\ni... are the qubit indices;\nparas is either:\na single scalar (for one-parameter gates), or\nan array of scalars (for multi-parameter gates);\nisparas is a Boolean keyword:\nisparas = false: the gate is treated as a fixed numerical gate;\nisparas = true: the gate is treated as having optimizable parameters, and its parameters will be tracked by the variational/gradient engine.\n\n","category":"section"},{"location":"manual/quantum-gates/#Examples:-Non-Parametric-and-Parametric-Gates","page":"Quantum gates","title":"Examples: Non-Parametric and Parametric Gates","text":"The following code illustrates how to construct basic non-parametric and parametric gates in MyJuliVQC:\n\nusing MyJuliVQC\n\n# Single-qubit X gate on qubit 1\nn = 1\nX = XGate(n)\n\n# Two-qubit CNOT: control = 1, target = 2\nncontrol = 1\nntarget  = 2\nCNOT = CNOTGate(ncontrol, ntarget)\n\n# Rx gate: non-parametric vs parametric\nθ = π / 2\n\n# a non-parametric Rx gate (angle fixed, not tracked as a variational parameter)\nnon_para_Rx = RxGate(n, θ; isparas = false)\n\n# a parametric Rx gate (its angle is treated as a variational parameter)\npara_Rx = RxGate(n, θ; isparas = true)","category":"section"},{"location":"manual/circuits/#Circuits","page":"Manipulating and running circuits","title":"Circuits","text":"In MyJuliVQC, a quantum circuit is represented by a lightweight wrapper type QCircuit, which internally stores a sequence of quantum operations.\n\nEach element of a QCircuit can be:\n\na (possibly parametric) unitary gate (e.g. HGate, RxGate, CNOTGate, …),\na quantum channel (e.g. AmplitudeDamping, Depolarizing, or a general QuantumMap),\nor another QCircuit (allowing circuit composition via concatenation of subcircuits).\n\nThis design keeps the circuit object simple and transparent while still being flexible enough to represent both noiseless and noisy variational circuits.\n\n","category":"section"},{"location":"manual/circuits/#Applying-a-Circuit-to-a-State","page":"Manipulating and running circuits","title":"Applying a Circuit to a State","text":"After constructing a circuit, you can apply it to a quantum state using:\n\napply!(circuit, state) – in-place evolution (modifies state directly)\napply(circuit, state) – out-of-place evolution (returns a new state)\ncircuit * state – equivalent to apply(circuit, state)\n\nHere, state can be either:\n\nStateVector – representing a pure state, or\nDensityMatrix – representing a mixed state (needed when quantum channels are present).\n\nFor variational quantum algorithms, the out-of-place form is often convenient, since it allows you to treat the circuit as a pure transformation and reuse the initial state.\n\n","category":"section"},{"location":"manual/circuits/#Example:-Building-and-Running-a-Simple-Circuit","page":"Manipulating and running circuits","title":"Example: Building and Running a Simple Circuit","text":"using MyJuliVQC\n\n# Initialize a 2-qubit |00⟩ state\nstate = StateVector(2)\n\n# Construct a circuit:\n#   1. H on qubit 1\n#   2. Ry(π/4) on qubit 1 (non-parametric here)\n#   3. CNOT with control = 1, target = 2\ncircuit = QCircuit([\n    HGate(1),\n    RyGate(1, π/4; isparas = false),\n    CNOTGate(1, 2),\n])\n\n# Apply the circuit in-place\napply!(circuit, state)\n\n# Measure qubit 2\noutcome, prob = measure!(state, 2)\nprintln(\"Measurement result on qubit 2 = $outcome (prob = $prob)\")\n\nYou can also build the same circuit incrementally:\n\nusing MyJuliVQC\n\nstate = StateVector(2)\ncircuit = QCircuit()\n\npush!(circuit, HGate(1))\npush!(circuit, RyGate(1, π/4; isparas = false))\npush!(circuit, CNOTGate(1, 2))\n\nψ_out = apply(circuit, state)   # out-of-place application\n\nIn more advanced workflows, parametric gates (with isparas = true) can be used together with the gradient engine described in the Automatic differentiation section to implement VQE, quantum classifiers, and other variational algorithms.","category":"section"},{"location":"examples/vqc-example/#VQC-example","page":"Creating a Variational Quantum Circuit","title":"VQC-example","text":"A variational quantum circuit (VQC) consists of quantum gates with parameters that can be optimized. The code below demonstrates how to build one step by step.\n\nusing MyJuliVQC\n\nconst gradientMJVQC = MyJuliVQC.gradient\n\n# -----------------------------\n# 1. Circuit parameters\n# -----------------------------\nL     = 3          # number of qubits\ndepth = 2          # circuit depth\n\n# -----------------------------\n# 2. Build a variational circuit\n# -----------------------------\ncircuit = QCircuit()\n\n# First layer: local rotations\nfor i in 1:L\n    push!(circuit, RzGate(i, rand();  isparas = true))\n    push!(circuit, RyGate(i, rand();  isparas = true))\n    push!(circuit, RzGate(i, rand();  isparas = true))\nend\n\n# Repeated entangling + rotations\nfor l in 1:depth\n    # entangling CNOT chain\n    for i in 1:L-1\n        push!(circuit, CNOTGate(i, i+1))\n    end\n    # another layer of local rotations\n    for i in 1:L\n        push!(circuit, RzGate(i, rand();  isparas = true))\n        push!(circuit, RxGate(i, rand();  isparas = true))\n        push!(circuit, RzGate(i, rand();  isparas = true))\n    end\nend\n\n# -----------------------------\n# 3. Initial state & Hamiltonian\n# -----------------------------\nψ0 = StateVector(L)              # |000⟩\nfunction heisenberg_1d(L; hz = 1.0, J = 1.0)\n    terms = QubitsTerm[]\n\n    # Local Z fields\n    for i in 1:L\n        push!(terms, QubitsTerm(i => \"Z\"; coeff = hz))\n    end\n\n    # Nearest-neighbor interactions: X X + Y Y + Z Z\n    for i in 1:L-1\n        push!(terms, QubitsTerm(i => \"X\", i+1 => \"X\"; coeff = J))\n        push!(terms, QubitsTerm(i => \"Y\", i+1 => \"Y\"; coeff = J))\n        push!(terms, QubitsTerm(i => \"Z\", i+1 => \"Z\"; coeff = J))\n    end\n\n    return QubitsOperator(terms)\nend\nH  = heisenberg_1d(L)            \n\n# -----------------------------\n# 4. Wrap loss as an expectation value\n#    loss(circ) = Re⟨ψ0| C(θ)† H C(θ) |ψ0⟩\n# -----------------------------\nloss_obj = LossExpectationRealSV(H, ψ0)\nE = loss_obj(circuit)\nprintln(\"Initial loss (energy) = \", E)\n\n# -----------------------------\n# 5. Extract parameters, compute gradient, update\n# -----------------------------\nθ  = active_parameters(circuit)\nprintln(\"Number of parameters = \", length(θ))\n\ngrads = gradientMJVQC(loss_obj, circuit)\nprintln(\"Gradient vector length = \", length(grads))\n\n# Gradient descent\nα      = 0.01\nθ_new  = θ .- α .* grads\nreset_parameters!(circuit, θ_new)\n\nE_new = loss_obj(circuit)\nprintln(\"Loss after one gradient step = \", E_new)","category":"section"},{"location":"#MyJuliVQC.jl-Documentation","page":"Home","title":"MyJuliVQC.jl Documentation","text":"MyJuliVQC.jl is an independent Julia implementation of variational quantum circuit (VQC) simulation methods, inspired by JuliVQC.jl.\n\nStart from the Getting Started section to install and run basic examples.","category":"section"}]
}
