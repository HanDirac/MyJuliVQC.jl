var documenterSearchIndex = {"docs":
[{"location":"getting-started/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"getting-started/installation/#1.-Create-a-Dedicated-Julia-Environment-(Highly-Recommended)","page":"Installation","title":"1. Create a Dedicated Julia Environment (Highly Recommended)","text":"We strongly recommend creating a dedicated Julia environment for MyJuliVQC.jl to prevent dependency conflicts with other projects. Follow these steps:\n\nOpen the Julia REPL.  \nNavigate to your project folder (or any desired directory).  \nActivate a new environment:  \njulia> ] activate .\njulia> ] instantiate\nThis creates a new Project.toml and an empty environment in the current folder.\n\n","category":"section"},{"location":"getting-started/installation/#2.-Install-MyJuliVQC","page":"Installation","title":"2. Install MyJuliVQC","text":"MyJuliVQC can be installed directly from GitHub:    julia    julia> ] add https://github.com/HanDirac/MyJuliVQC.jl\n\nThen load the package:        julia    julia> using MyJuliVQC\n\nIf this succeeds without errors, the installation is complete.\n\n","category":"section"},{"location":"manual/noise-channels/#Noise-Channels","page":"Noise channels","title":"Noise Channels","text":"","category":"section"},{"location":"examples/flux-example/#Flux-Example","page":"A Simple Application with Flux","title":"Flux Example","text":"","category":"section"},{"location":"examples/utilities/#Utilities","page":"Utility Functions","title":"Utilities","text":"","category":"section"},{"location":"manual/initialize-state/#Initialize-State","page":"Initialize a quantum state","title":"Initialize State","text":"The first step in using MyJuliVQC for quantum circuit simulation is to initialize a quantum state represented as a state vector. MyJuliVQC provides two constructors: StateVector for pure states and DensityMatrix for mixed states. \n\nFrom a mathematical viewpoint:\n\nAn n-qubit pure state should be understood as a a vector of size 2^n, corresponding to a rank-n tensor with each index of dimension 2.\nAn n-qubit mixed state is represented as a density matrix of size 2^n2^n, which can be viewed as a rank-2n tensor where each dimension also has size 2.\n\nInternal index conventions:\n\nFor pure states, qubits are internally labeled from 1 to n.\nFor mixed states, the ket indices are labeled from 1 to n, and the corresponding bra indices from n+1 to 2n.\n\nBoth state representations use column-major storage, meaning lower-index dimensions vary fastest.\n\nThese implementation details are generally irrelevant to typical users unless direct access to the raw data is required.\n\nusing MyJuliVQC\n\n# Initialize |00⟩ for 2 qubits\nstate = StateVector(2)\n\nn = 2\npure_state  = StateVector(n)\nmixed_state = DensityMatrix(n)\n\n# Custom pure state (user-specified vector)\ncustom_pure_state = StateVector([0.0, 0.1, 0.0, 0.0])\n\n# Custom mixed state (user-specified flattened matrix)\n# NOTE:\n#   If a vector is used to construct a DensityMatrix,\n#   **the vector must follow column-major (column-first) order**.\n#   That is, the matrix is flattened by stacking all columns in sequence.\ncustom_mixed_state = DensityMatrix([0.5, -0.5im, 0.5im, 0.5]) #column-major order)\n\n# -------------------------------------------------------\n# Construct an equivalent mixed state using a 2×2 matrix\n# -------------------------------------------------------\n\n# 2×2 density matrix explicitly written\nρmat = [\n    0.5      0.5im;\n   -0.5im    0.5\n]\n\n# Construct DensityMatrix from matrix form\nmixed_state_from_matrix = DensityMatrix(ρmat)\n\n# -------------------------------------------------------\n# Test equivalence\n# -------------------------------------------------------\n\nprintln(\"custom_mixed_state data = \", custom_mixed_state.data)\nprintln(\"mixed_state_from_matrix data = \", mixed_state_from_matrix.data)\n\n# They should match element-wise\nprintln(\"Are the two density matrices equal? \",\n        custom_mixed_state.data ≈ mixed_state_from_matrix.data)\n","category":"section"},{"location":"manual/threading-control/#Threading-Control-(MyJuliVQC-Extension)","page":"Threading control (MyJuliVQC)","title":"Threading Control (MyJuliVQC Extension)","text":"MyJuliVQC provides additional controls for threading and numeric precision, beyond the original JuliVQC implementation.\n\nusing MyJuliVQC\n\nMyJuliVQC.set_threading!(;\n    outer_threads = true,\n    dloc_threshold = 8,\n    blas_threads = 1,\n)\n\nThis page will describe:\n\nhow outer threading is applied in gate application,\ninteraction with BLAS threads,\nrecommended settings for different hardware (laptop / workstation / HPC).","category":"section"},{"location":"getting-started/quick-start/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"This page provides a short hands-on introduction to MyJuliVQC, showing how to construct, apply, and differentiate variational quantum circuits.\n\n","category":"section"},{"location":"getting-started/quick-start/#Example-1:-Preparing-a-Bell-State","page":"Quick Start","title":"Example 1: Preparing a Bell State","text":"The following script initializes a 2-qubit state, applies a simple quantum circuit, and performs a measurement:\n\nusing MyJuliVQC\n\n# Create a 2-qubit state |00⟩\nψ = StateVector(2)\n\n# Build a quantum circuit\ncircuit = QCircuit()\npush!(circuit, HGate(1))          # Hadamard on qubit 1\npush!(circuit, CNOTGate(1, 2))    # Controlled-NOT from qubit 1 to 2\n\n# Apply the circuit to the state\napply!(circuit, ψ)\n\n# Inspect the resulting state\nprintln(\"Final state vector:\")\nprintln(ψ)\n\n# Measure qubit 1\noutcome, prob = measure!(ψ, 1)\nprintln(\"Measured qubit 1 → $outcome   (probability = $prob)\")\n\n","category":"section"},{"location":"getting-started/quick-start/#Example-2:-A-Simple-Variational-Circuit","page":"Quick Start","title":"Example 2: A Simple Variational Circuit","text":"This example shows how to construct a parameterized circuit and evaluate a loss function:\n\nusing MyJuliVQC\nconst gradientMJVQC = MyJuliVQC.gradient\n\n# 1. initial state\nL  = 3                      # number of qubits\nψ0 = StateVector(L)         # |000⟩\n\n# 2. construct a simple variational circuit\ncircuit = QCircuit()\n\n# Layer 1: single-qubit rotations\nfor i in 1:L\n    push!(circuit, RzGate(i, rand(), isparas=true))\n    push!(circuit, RyGate(i, rand(), isparas=true))\n    push!(circuit, RzGate(i, rand(), isparas=true))\nend\n\n# Layer 2: entangling + rotations\nfor i in 1:L-1\n    push!(circuit, CNOTGate(i, i+1))\nend\nfor i in 1:L\n    push!(circuit, RxGate(i, rand(), isparas=true))\nend\n\n# 3. define a simple operator H\nH = QubitsOperator([QubitsTerm(1=>\"Z\", 2=>\"Z\", 3=>\"Z\"; coeff=1.0)])\n\n# 4. construct the loss\nloss_obj = LossExpectationRealSV(H, ψ0)\n\n# 5. compute the loss(expectation) with the current circuit\nprintln(\"Expectation value (loss) = \", loss_obj(circuit))\n\n# 6. use gradient to get the gradient\ngrads = gradientMJVQC(loss_obj, circuit)\nprintln(\"Gradient from MyJuliVQC.gradient:\")\nprintln(grads)\n\n\n","category":"section"},{"location":"manual/automatic-differentiation/#Automatic-Differentiation","page":"Automatic differentiation","title":"Automatic Differentiation","text":"","category":"section"},{"location":"manual/qubit-operators/#Qubit-Operators","page":"Qubit operators","title":"Qubit Operators","text":"","category":"section"},{"location":"manual/quantum-gates/#Quantum-Gates","page":"Quantum gates","title":"Quantum Gates","text":"","category":"section"},{"location":"manual/circuits/#Circuits","page":"Manipulating and running circuits","title":"Circuits","text":"","category":"section"},{"location":"examples/vqc-example/#VQC-example","page":"Creating a Variational Quantum Circuit","title":"VQC-example","text":"","category":"section"},{"location":"#MyJuliVQC.jl-Documentation","page":"Home","title":"MyJuliVQC.jl Documentation","text":"MyJuliVQC.jl is an independent Julia implementation of variational quantum circuit (VQC) simulation methods, inspired by JuliVQC.jl.\n\nStart from the Getting Started section to install and run basic examples.","category":"section"}]
}
