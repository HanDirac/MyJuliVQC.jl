<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Qubit operators · MyJuliVQC.jl</title><meta name="title" content="Qubit operators · MyJuliVQC.jl"/><meta property="og:title" content="Qubit operators · MyJuliVQC.jl"/><meta property="twitter:title" content="Qubit operators · MyJuliVQC.jl"/><meta name="description" content="Documentation for MyJuliVQC.jl."/><meta property="og:description" content="Documentation for MyJuliVQC.jl."/><meta property="twitter:description" content="Documentation for MyJuliVQC.jl."/><meta property="og:url" content="https://HanDirac.github.io/MyJuliVQC.jl/manual/qubit-operators/"/><meta property="twitter:url" content="https://HanDirac.github.io/MyJuliVQC.jl/manual/qubit-operators/"/><link rel="canonical" href="https://HanDirac.github.io/MyJuliVQC.jl/manual/qubit-operators/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MyJuliVQC.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../getting-started/installation/">Installation</a></li><li><a class="tocitem" href="../../getting-started/quick-start/">Quick Start</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../initialize-state/">Initialize a quantum state</a></li><li><a class="tocitem" href="../quantum-gates/">Quantum gates</a></li><li><a class="tocitem" href="../noise-channels/">Noise channels</a></li><li><a class="tocitem" href="../circuits/">Manipulating and running circuits</a></li><li class="is-active"><a class="tocitem" href>Qubit operators</a><ul class="internal"><li><a class="tocitem" href="#QubitsTerm:-Single-Term-Representation"><span>QubitsTerm: Single-Term Representation</span></a></li><li><a class="tocitem" href="#Constructing-QubitsTerm"><span>Constructing QubitsTerm</span></a></li><li><a class="tocitem" href="#QubitsOperator:-Sum-of-Terms"><span>QubitsOperator: Sum of Terms</span></a></li><li><a class="tocitem" href="#Simplification:-simplify!"><span>Simplification: <code>simplify!</code></span></a></li><li><a class="tocitem" href="#Example:-1D-Heisenberg-Hamiltonian"><span>Example: 1D Heisenberg Hamiltonian</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li><li><a class="tocitem" href="../automatic-differentiation/">Automatic differentiation</a></li><li><a class="tocitem" href="../threading-control/">Threading control (MyJuliVQC)</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/vqc-example/">Creating a Variational Quantum Circuit</a></li><li><a class="tocitem" href="../../examples/flux-example/">A Simple Application with Flux</a></li><li><a class="tocitem" href="../../examples/utilities/">Utility Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Qubit operators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Qubit operators</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/HanDirac/MyJuliVQC.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/HanDirac/MyJuliVQC.jl/blob/main/docs/src/manual/qubit-operators.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Qubit-Operators"><a class="docs-heading-anchor" href="#Qubit-Operators">Qubit Operators</a><a id="Qubit-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Qubit-Operators" title="Permalink"></a></h1><p>In MyJuliVQC, multi-qubit observables and Hamiltonians are represented using two closely related types:</p><ul><li><code>QubitsTerm</code> – a single Pauli-string–style term (or more generally, a product of one-qubit operators with a scalar coefficient).</li><li><code>QubitsOperator</code> – a container holding a sum of <code>QubitsTerm</code> objects.</li></ul><p>This design provides a flexible way to build spin Hamiltonians, tensor-product observables, and general operators needed in variational quantum algorithms.</p><p>Once a <code>QubitsOperator</code> <code>op</code> has been constructed, its expectation value on a state (either <code>StateVector</code> or <code>DensityMatrix</code>) can be computed with:</p><pre><code class="language-julia hljs">expectation(op, state)</code></pre><p>(implemented in a separate file; not in <code>qubits_term.jl</code> / <code>qubitsoperator.jl</code> directly).</p><hr/><h2 id="QubitsTerm:-Single-Term-Representation"><a class="docs-heading-anchor" href="#QubitsTerm:-Single-Term-Representation">QubitsTerm: Single-Term Representation</a><a id="QubitsTerm:-Single-Term-Representation-1"></a><a class="docs-heading-anchor-permalink" href="#QubitsTerm:-Single-Term-Representation" title="Permalink"></a></h2><p>A <code>QubitsTerm</code> represents a single product of local operators acting on specific qubits.</p><h3 id="Accessors"><a class="docs-heading-anchor" href="#Accessors">Accessors</a><a id="Accessors-1"></a><a class="docs-heading-anchor-permalink" href="#Accessors" title="Permalink"></a></h3><p>There are basic operations:</p><pre><code class="language-julia hljs">copy(t::QubitsTerm)
isempty(t::QubitsTerm)
adjoint(t::QubitsTerm)        # Hermitian conjugate (†), conjugating coeff and local matrices
3 * t                         # scalar multiplication (left or right)
Base.eltype(t::QubitsTerm)    # promoted numeric element type</code></pre><hr/><h2 id="Constructing-QubitsTerm"><a class="docs-heading-anchor" href="#Constructing-QubitsTerm">Constructing QubitsTerm</a><a id="Constructing-QubitsTerm-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-QubitsTerm" title="Permalink"></a></h2><p>Several convenience constructors are provided.</p><h3 id="1.-From-explicit-vectors"><a class="docs-heading-anchor" href="#1.-From-explicit-vectors">1. From explicit vectors</a><a id="1.-From-explicit-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#1.-From-explicit-vectors" title="Permalink"></a></h3><pre><code class="language-julia hljs">QubitsTerm(pos::Vector{Int}, m::Vector, v::Number)
QubitsTerm(pos::Tuple,       m::Vector, v::Number)</code></pre><p>Example:</p><pre><code class="language-julia hljs">using MyJuliVQC

pos = [2, 1]
ops = [&quot;X&quot;, &quot;Z&quot;]    # will be mapped to matrices via _op_mapping
t   = QubitsTerm(pos, ops, 0.5)</code></pre><p>Internally, <code>pos</code> and <code>ops</code> are normalized to ascending qubit order using an internal helper <code>_get_normal_order</code>, so the canonical representation is on qubits <code>[1, 2]</code>.</p><h3 id="2.-From-a-dictionary"><a class="docs-heading-anchor" href="#2.-From-a-dictionary">2. From a dictionary</a><a id="2.-From-a-dictionary-1"></a><a class="docs-heading-anchor-permalink" href="#2.-From-a-dictionary" title="Permalink"></a></h3><pre><code class="language-julia hljs">QubitsTerm(x::AbstractDict{Int}; coeff::Number = 1.0)</code></pre><ul><li>keys: <code>Int</code> (1-based qubit indices),</li><li>values: either strings (<code>&quot;X&quot;</code>, <code>&quot;Z&quot;</code>, …) or explicit <code>2×2</code> matrices.</li></ul><p>Example:</p><pre><code class="language-julia hljs">using MyJuliVQC

t = QubitsTerm(Dict(1 =&gt; &quot;X&quot;, 3 =&gt; &quot;Y&quot;); coeff = 2.0)</code></pre><p>Internally, the dictionary is decomposed by <code>dict_to_site_ops</code> into <code>(sites, ops)</code> and passed to the main constructor.</p><h3 id="3.-From-pairs"><a class="docs-heading-anchor" href="#3.-From-pairs">3. From pairs</a><a id="3.-From-pairs-1"></a><a class="docs-heading-anchor-permalink" href="#3.-From-pairs" title="Permalink"></a></h3><p>This is often the most convenient syntax in user code:</p><pre><code class="language-julia hljs">QubitsTerm(i1 =&gt; op1, i2 =&gt; op2, ...; coeff::Number = 1.0)</code></pre><p>Each pair uses:</p><ul><li>key: <code>Int</code> for the qubit index.</li><li>value: either<ul><li>an <code>AbstractString</code> (e.g. <code>&quot;X&quot;</code>, <code>&quot;Y&quot;</code>, <code>&quot;Z&quot;</code>, <code>&quot;I&quot;</code>, <code>&quot;+&quot;</code>, <code>&quot;-&quot;</code>, <code>&quot;u&quot;</code>, <code>&quot;d&quot;</code>, <code>&quot;0&quot;</code>, <code>&quot;1&quot;</code>), or</li><li>an <code>AbstractMatrix</code> (typically a <code>2×2</code> matrix).</li></ul></li></ul><p>These symbolic labels are mapped to matrices using the internal <code>_op_mapping</code> table:</p><pre><code class="language-julia hljs">const _op_mapping = Dict(
    &quot;X&quot; =&gt; [0. 1.; 1. 0.],
    &quot;Y&quot; =&gt; [0. -im; im 0.],
    &quot;Z&quot; =&gt; [1. 0.; 0. -1.],
    &quot;+&quot; =&gt; [0. 1.; 0. 0.],
    &quot;-&quot; =&gt; [0. 0.; 1. 0.],
    &quot;I&quot; =&gt; [1. 0.; 0. 1.],
    &quot;u&quot; =&gt; [1. 0.; 0. 0.],
    &quot;d&quot; =&gt; [0. 0.; 0. 1.],
    &quot;0&quot; =&gt; [1. 0.; 0. 0.],
    &quot;1&quot; =&gt; [0. 0.; 0. 1.],
)</code></pre><p>Examples:</p><pre><code class="language-julia hljs">using MyJuliVQC

# Using string operators
t1 = QubitsTerm(1 =&gt; &quot;X&quot;, 3 =&gt; &quot;Y&quot;; coeff = 0.5)

# Using explicit matrices
σx = [0. 1.; 1. 0.]
t2 = QubitsTerm(2 =&gt; σx, 4 =&gt; &quot;Z&quot;; coeff = 1.0 + 0.0im)

# Equivalent to constructing from Dict
t3 = QubitsTerm(Dict(1 =&gt; &quot;X&quot;, 3 =&gt; &quot;Y&quot;); coeff = 0.5)</code></pre><p>Notes:</p><ul><li>All pairs are collected into a <code>Dict</code> first and then normalized to ascending qubit order.</li><li>If duplicate indices appear, the last one wins (dictionary semantics).</li></ul><hr/><h2 id="QubitsOperator:-Sum-of-Terms"><a class="docs-heading-anchor" href="#QubitsOperator:-Sum-of-Terms">QubitsOperator: Sum of Terms</a><a id="QubitsOperator:-Sum-of-Terms-1"></a><a class="docs-heading-anchor-permalink" href="#QubitsOperator:-Sum-of-Terms" title="Permalink"></a></h2><p><code>QubitsOperator</code> is a container for a <strong>sum of QubitsTerm</strong>, representing a Hamiltonian or general observable.</p><h3 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h3><pre><code class="language-julia hljs">QubitsOperator()                      # empty operator
QubitsOperator(t1, t2, ...)          # from varargs QubitsTerm
QubitsOperator(ts::Vector{&lt;:QubitsTerm})
QubitsOperator(ts::AbstractVector)   # will be collected as Vector{QubitsTerm}</code></pre><p>Example:</p><pre><code class="language-julia hljs">using MyJuliVQC

op = QubitsOperator()
push!(op, QubitsTerm(1 =&gt; &quot;X&quot;, 2 =&gt; &quot;Z&quot;; coeff = 0.5))</code></pre><h3 id="Collection-like-interface"><a class="docs-heading-anchor" href="#Collection-like-interface">Collection-like interface</a><a id="Collection-like-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Collection-like-interface" title="Permalink"></a></h3><pre><code class="language-julia hljs">length(op::QubitsOperator)
isempty(op::QubitsOperator)
getindex(op::QubitsOperator, i::Int)
iterate(op::QubitsOperator)
copy(op::QubitsOperator)
push!(op::QubitsOperator, t::QubitsTerm)</code></pre><p>You can also inspect it via <code>show</code>:</p><pre><code class="language-julia hljs">println(op)
# QubitsOperator with N term(s):
#  [1] positions = ..., coeff = ...</code></pre><h3 id="Algebraic-operations"><a class="docs-heading-anchor" href="#Algebraic-operations">Algebraic operations</a><a id="Algebraic-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Algebraic-operations" title="Permalink"></a></h3><pre><code class="language-julia hljs">adjoint(op::QubitsOperator)    # term-wise Hermitian conjugate
λ * op                         # scalar multiplication
op * λ                         # scalar multiplication (commutative)
A + B                          # concatenation of terms from A and B</code></pre><hr/><h2 id="Simplification:-simplify!"><a class="docs-heading-anchor" href="#Simplification:-simplify!">Simplification: <code>simplify!</code></a><a id="Simplification:-simplify!-1"></a><a class="docs-heading-anchor-permalink" href="#Simplification:-simplify!" title="Permalink"></a></h2><pre><code class="language-julia hljs">simplify!(op::QubitsOperator)</code></pre><p>This in-place operation:</p><ul><li>merges terms having the <strong>same</strong> <code>positions</code> and the <strong>same</strong> sequence of local matrices (tested via an exact string-based key), and</li><li>replaces them with a single term whose coefficient is the sum of the original coefficients.</li></ul><p>Internally, it builds a <code>Dict{String,QubitsTerm}</code> keyed by a serialization of:</p><ul><li>the positions vector,</li><li>and the flattened matrices in <code>oplist(t)</code>.</li></ul><p>This is robust for canonical Pauli-string terms constructed via <code>&quot;X&quot;</code>, <code>&quot;Y&quot;</code>, etc., because their matrices are fixed. However:</p><blockquote><p>If the user supplies slightly different but mathematically equivalent matrices (e.g. <code>[0 1; 1 0]</code> vs <code>[0.0 1.0; 1.0 0.0]</code>), they may not be merged, since the string representations differ.</p></blockquote><p>Typical usage:</p><pre><code class="language-julia hljs">using MyJuliVQC
op = QubitsOperator(
    QubitsTerm(1=&gt;&quot;X&quot;, 2=&gt;&quot;X&quot;; coeff=1.0),
    QubitsTerm(1=&gt;&quot;X&quot;, 2=&gt;&quot;X&quot;; coeff=2.0),
)

simplify!(op)
# Now op has a single term with coeff = 3.0</code></pre><hr/><h2 id="Example:-1D-Heisenberg-Hamiltonian"><a class="docs-heading-anchor" href="#Example:-1D-Heisenberg-Hamiltonian">Example: 1D Heisenberg Hamiltonian</a><a id="Example:-1D-Heisenberg-Hamiltonian-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-1D-Heisenberg-Hamiltonian" title="Permalink"></a></h2><p>The following function builds a standard 1D Heisenberg Hamiltonian on <code>L</code> qubits:</p><pre><code class="language-julia hljs">using MyJuliVQC

function heisenberg_1d(L; hz = 1.0, J = 1.0)
    terms = QubitsTerm[]

    # Local Z fields
    for i in 1:L
        push!(terms, QubitsTerm(i =&gt; &quot;Z&quot;; coeff = hz))
    end

    # Nearest-neighbor interactions: X X + Y Y + Z Z
    for i in 1:L-1
        push!(terms, QubitsTerm(i =&gt; &quot;X&quot;, i+1 =&gt; &quot;X&quot;; coeff = J))
        push!(terms, QubitsTerm(i =&gt; &quot;Y&quot;, i+1 =&gt; &quot;Y&quot;; coeff = J))
        push!(terms, QubitsTerm(i =&gt; &quot;Z&quot;, i+1 =&gt; &quot;Z&quot;; coeff = J))
    end

    return QubitsOperator(terms)
end</code></pre><p>You can then use this operator with <code>expectation</code>:</p><pre><code class="language-julia hljs">ψ = StateVector(3)
H = heisenberg_1d(3)
E = expectation(H, ψ)
println(&quot;⟨ψ|H|ψ⟩ = &quot;, E)</code></pre><p>For mixed states:</p><pre><code class="language-julia hljs">ρ = DensityMatrix(3)
Eρ = expectation(H, ρ)
println(&quot;Tr(ρ H) = &quot;, Eρ)</code></pre><hr/><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><ul><li><code>QubitsTerm</code> encodes a single Pauli-string–like term with a scalar coefficient.</li><li><code>QubitsOperator</code> is a sum of such terms, suitable for Hamiltonians and observables.</li><li>Constructors accept vectors, dictionaries, and <code>i =&gt; op</code> pairs, with string labels mapped to predefined 2×2 matrices.</li><li><code>simplify!</code> merges identical terms by summing coefficients.</li><li>These structures integrate naturally with <code>expectation(op, state)</code> and the variational/gradient engine in MyJuliVQC.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../circuits/">« Manipulating and running circuits</a><a class="docs-footer-nextpage" href="../automatic-differentiation/">Automatic differentiation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 29 November 2025 03:42">Saturday 29 November 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
